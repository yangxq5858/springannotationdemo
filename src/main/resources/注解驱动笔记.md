

# 注解驱动笔记







## 1.容器组件注册（IOC）的3种方式

### 总结

#### a: 组件扫描 + 组件标注（@Controller @Service @Repository @Component)

自己写的组件，采用这种方式，因为可以修改源代码，在组件上面标注

#### b: @Bean

第三行包中的组件，我们没有办法自己修改源代码的情况，我们采用这种方式，在配置类中，new 一个对象出来

标注上@Bean，加入到容器中

#### c：@Import

也是第三行的包中的组件，这种方式要快速些。

##### 1. @Import({Color.class,Blue.class}) 直接输入要导入的类

##### 2.@ImportSelector 自定义返回一个全路径类名的数组

注意，这里同样是采用@Import的方式导入的，只是导入的是一个Selector类

```java
@Configuration
@Import({Color.class, MyImportSelector.class})
public class ImportComponentConfig {
}
```

```java
public class MyImportSelector implements ImportSelector {

    public String[] selectImports(AnnotationMetadata importingClassMetadata) {

        return new String[]{"com.hx.bean.Blue","com.hx.bean.Yellow"};
    }
}
```

#####  3.ImportBeanDefinitionRegistrar 这种方式可以自定义导入组件的名称

自定义规则

```java
public class MyImportBeanDefinitionRegistrar implements ImportBeanDefinitionRegistrar {
    /**
     *
     * @param importingClassMetadata 当前类的注解信息
     * @param registry bean定义的注册类
     */
    public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {

        boolean blue = registry.containsBeanDefinition("com.hx.bean.Blue");
        boolean yellow = registry.containsBeanDefinition("com.hx.bean.Yellow");
        RootBeanDefinition rootBeanDefinition = new RootBeanDefinition(Red.class);
        rootBeanDefinition.setScope("prototype"); //设置组件的作用域，多例模式创建
        if (blue && yellow){
            registry.registerBeanDefinition("Red",rootBeanDefinition);
          //这里就可以对组件的名称进行修改了
        }
    }
}

```

导入

```java
@Configuration
@Import({Color.class, MyImportSelector.class,MyImportBeanDefinitionRegistrar.class})
public class ImportComponentConfig {
}

```

##### 4.BeanFactory<T>接口实现的类 结合@Bean 注册

这种方式是Spring整合第三方框架时，使用较多

**注意：工厂创建的类在注册进去后，我们在容器中拿到的类不是工厂类，而是工厂中getObject中产生的类**

```java
/**
 * @author yxqiang
 * @create 2018-09-24 17:03
 * 创建一个Spring定义的工厂Bean
 */
public class ColorFactoryBean implements FactoryBean<Color> {
    public Color getObject() throws Exception {
        return new Color();
    }

    public Class<?> getObjectType() {
        return Color.class;
    }

    public boolean isSingleton() {
        return false;
    }
}
```



在注册类中标注一个工厂bean

```
@Bean
public ColorFactoryBean colorFactoryBean(){
    return new ColorFactoryBean();
}
```

测试

```java
@Test
public void test6(){
    AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(MainConfig.class);
    PrintNames(applicationContext);
    Object colorFactoryBean = applicationContext.getBean("colorFactoryBean");
    System.out.println("colorFactoryBean的类型="+colorFactoryBean.getClass());
}
```

输出

```java
colorFactoryBean
colorFactoryBean的类型=class com.hx.bean.Color

```

如果要拿到beanFactory 这个Bean，需要在bean 的id前加一个&符号

```java
public void test6(){
    AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(MainConfig.class);
    PrintNames(applicationContext);
    Object colorFactoryBean = applicationContext.getBean("colorFactoryBean");
    System.out.println("colorFactoryBean的类型="+colorFactoryBean.getClass());
    Object bean = applicationContext.getBean("&colorFactoryBean"); //这个就是获取工厂bean本身的对象
    System.out.println(bean.getClass());

}
```

**Spring中的BeanFactory接口中，有一个默认的前缀 &**

```java
public interface BeanFactory {
    String FACTORY_BEAN_PREFIX = "&";

    Object getBean(String var1) throws BeansException;
```













### 1)采用配置类，代替xml配置的方式

```java

@Configuration //表示这是一个配置类
public class MainConfig {

    @Bean //给容器中注册一个bean，类型为返回值类型，id为返回值的名字
    public Person person(){
        return new Person("lisi",18); //注意，这里是手工new 了一个对象
    }
}

```

```java
public class Person {
    public String name;
    public Integer age;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Integer getAge() {
        return age;
    }

    public void setAge(Integer age) {
        this.age = age;
    }

    public Person(String name, Integer age) {
        this.name = name;
        this.age = age;
    }

    public Person() {
        super();
    }

    @Override
    public String toString() {
        return "Person{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }
}
```

**怎么使用**

```java
public class MainTest {

    public static void main(String[] args) {
        //这是以前xml配置文件的方式
        ApplicationContext applicationContext = new ClassPathXmlApplicationContext("bean.xml");
        applicationContext.getBean("person");
        //这是采用注解配置的方式
        AnnotationConfigApplicationContext annotationConfigApplicationContext = new AnnotationConfigApplicationContext(MainConfig.class);
        Person person = (Person) annotationConfigApplicationContext.getBean("person");
        System.out.println(person);
    }
}
```



### 2）包扫描的方式注入多个

```java
@ComponentScan(value="com.hx") //对@Controller @Repository @Service @Component 都会扫描出来
```

包扫描，还有多个参数，有包含和不包含包规则的用法

```java
//@ComponentScan //对@Controller @Repository @Service @Component 都会扫描出来
@ComponentScan(value = "com.hx",
//        excludeFilters = {
//        //表示过滤规则为：排除类型为注解类型的，类 = Controller的
//        @ComponentScan.Filter(type = FilterType.ANNOTATION, classes = {Controller.class})
//},
        //表示 只包含的类型
        includeFilters = {
                //表示过滤规则为：类型为注解类型的，类 = Controller的
                @ComponentScan.Filter(type = FilterType.ANNOTATION, classes = {Service.class}),
                //表示过滤类型为 指定的类
                @ComponentScan.Filter(type = FilterType.ASSIGNABLE_TYPE, classes = {com.hx.com.hx.controller.BookController.class}),
                //按自定义规则 过滤
                @ComponentScan.Filter(type= FilterType.CUSTOM,classes = {MyFilterTypeImp.class})

        },
        useDefaultFilters = false //这个参数，默认为true，表示全部扫描，启用只包含时，要关闭此参数才生效
)
public class ComponentScanConfig {
}

```

```java
@Repeatable(ComponentScans.class) //表示ComponentScan注解，可以重复即多次在同一个对象上使用
public @interface ComponentScan {
```

### 3）@Scope 创建对象的作用域

```
@Configuration
public class MainConfig {

    /**
     *        ConfigurableBeanFactory#SCOPE_PROTOTYPE prototype 多例 ioc启动时，不会创建对象，访问时，才会创建对象
     *        ConfigurableBeanFactory#SCOPE_SINGLETON singleton 单例 ioc启动时，默认是要创建对象，以后每次访问都是从 map.get() 一个对象
     *        org.springframework.web.context.WebApplicationContext#SCOPE_REQUEST request 表示同一个请求一个
     *        org.springframework.web.context.WebApplicationContext#SCOPE_SESSION session 表示同一个Session生成一个
     */


    @Scope(scopeName = "prototype")
    @Bean(name = "person")//重新定义bean的名字为person
    public Person person1() {
        return new Person("lisi", 18);
    }
}
```

### 4）@Lazy 懒加载（针对单实例）

IOC 创建完成时，不会添加对象到容器中个，只有在第一次使用时，才会创建

```java
@Lazy
@Bean(name = "person")//重新定义bean的名字为person
public Person person1() {
    System.out.println("IOC容器创建 Person 对象了...");
    return new Person("lisi", 18);
}
```



### 5）@Conditional 满足条件注册bean

SpringBoot中大量使用这种方式

Ctrl + shift+ T 打开一个类型（Open Type），输入Conditional。

```java
public interface Condition {

   /**
    * Determine if the condition matches.
    * @param context the condition context
    * @param metadata metadata of the {@link org.springframework.core.type.AnnotationMetadata class}
    * or {@link org.springframework.core.type.MethodMetadata method} being checked.
    * @return {@code true} if the condition matches and the component can be registered
    * or {@code false} to veto registration.
    */
   boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata);

}

```

定义两个条件类

```java
public class WindowsCondition implements Condition {

    public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {
        //1.能获取到bean的装配工厂
        ConfigurableListableBeanFactory beanFactory = context.getBeanFactory();

        //2.能获取到类加载器
        ClassLoader classLoader = context.getClassLoader();

        //3.能获取到当前的环境变量
        Environment environment = context.getEnvironment();

        //4.能获取到bean定义的注册类（可以注册和移除组件等）
        BeanDefinitionRegistry beanDefinitionRegistry = context.getRegistry();

        //我们这里只使用环境变量
        String property = environment.getProperty("os.name");
        if (property.contains("Windows")){
            return true;
        }

        return false;
    }
}
```

```java
 /**
     *
     * ConditionContext 判断条件能使用的上下文环境
     * AnnotatedTypeMetadata 注释信息
     * @return
     */
    public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {

        //1.能获取到bean的装配工厂
        ConfigurableListableBeanFactory beanFactory = context.getBeanFactory();

        //2.能获取到类加载器
        ClassLoader classLoader = context.getClassLoader();

        //3.能获取到当前的环境变量
        Environment environment = context.getEnvironment();

        //4.能获取到bean定义的注册类（可以注册和移除组件等）
        BeanDefinitionRegistry beanDefinitionRegistry = context.getRegistry();

        //我们这里只使用环境变量
        String property = environment.getProperty("os.name");
        if (property.contains("Linux")){
            return true;
        }

        return false;
    }
}
```

在配置类上标上注解

```java
/**
 * @author yxqiang
 * @create 2018-09-24 15:34
 *
 * 使用Conditional条件注册组件
 *
 * 当操作系统为windows时，注册person001，当操作系统各位linux时，注册person002组件
 */
@Conditional(WindowsCondition.class) //条件注册也可以放到类上面，表示满足条件时，下面的对象才会被注册进容器中
@Configuration
public class ConditionalConfig {

//    @Conditional(WindowsCondition.class)
    @Bean("person-windows")
    public Person person001(){
        return new Person("Windows Pserson",20);
    }

//    @Conditional(LinuxCondition.class)
    @Bean("person-linux")
    public Person person002(){
        return new Person("Linux Pserson",20);
    }
}

```



### 6）@Import(Color.class) 导入第三方包

@Bean 也是可以导入第三方包的

```java
@Configuration
@Import(Color.class)
public class ImportComponentConfig {
}
```

IOC容器中得到的名字为：com.hx.bean.Color **全路径类名**

## 2.Bean的生命周期

```
Bean 的生命周期
   bean的创建 --> 初始化 -->销废
 对象创建：
 *      单实例：在容器初始化时，创建
 *      多实例：在第一次使用时，创建
 *   对象初始化：
 *      对象创建完成后，并赋值后，调用初始化方法
 *   对象销废：
 *      单实例：容器关闭时，销废
 *      多实例：容器不管你，即不销废
 
 
```

4种方式，可以实现对Bean生命周期进行管理

### 1) 通过@Bean中的参数指定初始化和销废的方法（init destory）

```java
public class Car {
    public Car(){
        System.out.println("Car construct...");
    }
    public void init(){
        System.out.println("Car init...");
    }
    public void destory(){
        System.out.println("Car destory...");
    }
}
```

```java
@Bean(initMethod = "init",destroyMethod = "destory")
public Car car(){
    return new Car();
}
```

### 2)通过让bean组件实现初始化和销废的接口来实现*      InitializingBean, DisposableBean 这2个接口

```java
public class Computer implements InitializingBean, DisposableBean {

    public Computer(){
        System.out.println("Computer constructor...");
    }


    public void afterPropertiesSet() throws Exception {
        System.out.println("Computer Init....");

    }

    public void destroy() throws Exception {
        System.out.println("Computer destory...");

    }
}
```

### 3)通过jdk的JSR250 自带的注解

```
@PostConstruct 在bean创建完成，并赋值后，进行
@PreDestory    在bean销废之前，进行通知清理工作
```

```java
public class Flower {

    public Flower(){
        System.out.println("Flower contructor...");
    }

    @PostConstruct
    public void init(){
        System.out.println("Flower init...");
    }

    @PreDestroy
    public void destory(){
        System.out.println("Flower destory");
    }
}
```

### 4)实现Spring的BeanPostProcessor【Interface】的2个方法

```java
postProcessBeforeInitialization: 在bean创建后，初始化之前调用
postProcessAfterInitialization:  在bean初始化之后调用
```



执行顺序

```
  执行顺序结果
*      Car construct...
*      postProcessBeforeInitialization car=>com.hx.bean.Car@15761df8
*      Car init...
*      postProcessAfterInitialization car=>com.hx.bean.Car@15761df8
```

### 5)Spring 底层框架大量使用 BeanPostProcessor 后置处理器

不管是bean的赋值，注入其他组件，@Autowired，生命周期注解功能等等，都是用的BeanPostProcessor来完成的

```java
BeanPostProcessor (org.springframework.beans.factory.config)
//以下都是BeanPostProcessor的实现类
MyPostProcessor (com.hx.bean) //自己写的实现类

AdvisorAdapterRegistrationManager (org.springframework.aop.framework.adapter)

BeanPostProcessorChecker in PostProcessorRegistrationDelegate (org.springframework.context.support)

LoadTimeWeaverAwareProcessor (org.springframework.context.weaving)

AbstractAdvisingBeanPostProcessor (org.springframework.aop.framework)

DestructionAwareBeanPostProcessor (org.springframework.beans.factory.config)
//
ApplicationContextAwareProcessor (org.springframework.context.support)

MergedBeanDefinitionPostProcessor (org.springframework.beans.factory.support)

BeanValidationPostProcessor (org.springframework.validation.beanvalidation)

InstantiationAwareBeanPostProcessor (org.springframework.beans.factory.config)

```

通过ApplicationContextAware接口，可以得到IOC容器

```java
public class Dog implements ApplicationContextAware {

    private ApplicationContext applicationContext;

    public Dog(){
        System.out.println("Dog contructor...");
    }

    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
        this.applicationContext = applicationContext;
    }
}

```

为什么实现ApplicationContextAware接口，可以得到IOC容器

```java
class ApplicationContextAwareProcessor implements BeanPostProcessor {

@Override
public Object postProcessBeforeInitialization(final Object bean, String beanName) throws BeansException {
		AccessControlContext acc = null;

		if (System.getSecurityManager() != null &&
				(bean instanceof EnvironmentAware || bean instanceof EmbeddedValueResolverAware ||
						bean instanceof ResourceLoaderAware || bean instanceof ApplicationEventPublisherAware ||
						bean instanceof MessageSourceAware || bean instanceof ApplicationContextAware //1. 判断bean是否是实现了ApplicationContextAware接口)) {
			acc = this.applicationContext.getBeanFactory().getAccessControlContext();
		}

		if (acc != null) {
			AccessController.doPrivileged(new PrivilegedAction<Object>() {
				@Override
				public Object run() {
					invokeAwareInterfaces(bean);
					return null;
				}
			}, acc);
		}
		else {
			invokeAwareInterfaces(bean); //acc不为空时，调用invokeAwareInterfaces
		}

		return bean;
	}

}
```

```java
private void invokeAwareInterfaces(Object bean) {
   if (bean instanceof Aware) {
      if (bean instanceof EnvironmentAware) {
         ((EnvironmentAware) bean).setEnvironment(this.applicationContext.getEnvironment());
      }
      if (bean instanceof EmbeddedValueResolverAware) {
         ((EmbeddedValueResolverAware) bean).setEmbeddedValueResolver(this.embeddedValueResolver);
      }
      if (bean instanceof ResourceLoaderAware) {
         ((ResourceLoaderAware) bean).setResourceLoader(this.applicationContext);
      }
      if (bean instanceof ApplicationEventPublisherAware) {
         ((ApplicationEventPublisherAware) bean).setApplicationEventPublisher(this.applicationContext);
      }
      if (bean instanceof MessageSourceAware) {
         ((MessageSourceAware) bean).setMessageSource(this.applicationContext);
      }
     //当实现了ApplicationContextAware接口时，要调用setApplicationContext(this.applicationContext)，将ioc容器传递给bean，这样bean就可以得到IOC容器了
      if (bean instanceof ApplicationContextAware) {
         ((ApplicationContextAware) bean).setApplicationContext(this.applicationContext);
      }
   }
}
```

## 3.Bean赋值

### 1)使用@Value赋值

```
public class Person {

    //使用@Value赋值
    //1. 基本类型的值
    //2. 可以用SpEL表达式 #{20-2}
    //3. 可以使用环境变量中的值 ${}
    @Value("yxqiang888")
    public String name;
    @Value("#{20-2}")
    public Integer age;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Integer getAge() {
        return age;
    }

    public void setAge(Integer age) {
        this.age = age;
    }

    public Person(String name, Integer age) {
        this.name = name;
        this.age = age;
    }

    public Person() {
        super();
    }

    @Override
    public String toString() {
        return "Person{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }
}
```

### 2)PropertySource读取外部配置文件

```
//使用PropertySource读取外部配置文件的key/value 保存到运行的环境变量中，Bean的属性上就可以使用${key}获取值
@PropertySource(value="classpath:/person.properties")
```

环境变量是指Spring IOC中的environment

```java
//获取IOC中的环境变量
ConfigurableEnvironment environment = applicationContext.getEnvironment();
String nikeName = environment.getProperty("person.nikeName");
System.out.println(nikeName); //同样可以得到值	
```



Bean上的属性，就可以采用表达式获取值了

```java
public class Person {

    //使用@Value赋值
    //1. 基本类型的值
    //2. 可以用SpEL表达式 #{20-2}
    //3. 可以使用环境变量中的值 ${}
    @Value("yxqiang888")
    private String name;
    @Value("#{20-2}")
    private Integer age;

    @Value("${person.nikeName}") //这里就是读取的配置文件保存在环境变量中的值
    private String nickName;

```



### 3) 自动装配

Spring利用依赖注入（DI），完成对IOC容器中各个组件的依赖关系赋值, **AutowiredAnnotationBeanPostProcessor** 来实现自动注入的

以下为自动装配的3种方式，推荐使用Spring提供的@Autowired。

####  1. @AutoWired

```java
@Controller
public class BookController {

    @Autowired
    private BookService bookService;
}
```

```java
@Service
public class BookService {
  /**
   //AutoWired装配规则
   1）默认优先按照类型去容器中查找，找到就装配，如：
     BookDao bean = applicationContext.getBean(BookDao.class);
   2）如果查找到多个组件，再将属性的名称作为id去IOC容器中查找
     BookDao bean = applicationContext.getBean(BookDao.class);
   3）使用 @Qualifier("bookDao") 注解，明确指定是哪一个Bean，用于自动装配进来
   4) 使用 @Primary在Bean上标注，表示多个实例时，优先装配的Bean；前提是没有使用@Qualifier
   5）@Autowired(required = false) //required = false 表示能装配上，就装配，否则为空时，要报错
 */    
     
     
    @Autowired
    private BookDao bookDao;
}
```

```java
public class AutoWiredConfig {
    @Primary //指明当前的Bean为默认首选的Bean
    @Bean("bookDao2")
    public BookDao bookDao(){
        BookDao bookDao = new BookDao();
        bookDao.setLabel("2");
        return bookDao;
    }
}
```

#### 2.@Resource

JSR250规范

@Resource(name="bookDao2")：

   可以和@Autowired一样实现自动装配，默认也是按照属性名称来装配组件的，也可以指定名称

   没有能支持@Primary 和 @Qulifier,以及@Autowired(required=false)的特性。

#### 3.@Inject

JSR330规范

@Inject：

​    需要在POM中单独导入 javax.inject的包，和Autowired功能基本一样，没有 @Primary支持

### 4)@Autowired 几种用法

#### 1.标注在方法上

```java
@Component
public class Boss {

    private Car car;

    public Car getCar() {
        return car;
    }

    @Autowired
    public void setCar(Car car) {
        this.car = car;
    }

    @Override
    public String toString() {
        return "Boss{" +
                "car=" + car +
                '}';
    }
}
```

#### 2.标注在构造器上

```java
@Component
public class Boss {

    @Autowired
    public Boss(Car car){
        this.car = car;
    }
    private Car car;
    public Car getCar() {
        return car;
    }
//    @Autowired
    public void setCar(Car car) {
        this.car = car;
    }
    @Override
    public String toString() {
        return "Boss{" +
                "car=" + car +
                '}';
    }
}
```

#### 3.标注在参数上

如果构造器上只有一个参数，可以省略@Autowired

```java
@Component
public class Boss {

//    @Autowired
    public Boss(@Autowired Car car){ //标注在参数上
        this.car = car;
    }
    private Car car;
    public Car getCar() {
        return car;
    }
//    @Autowired
    public void setCar(Car car) {
        this.car = car;
    }
    @Override
    public String toString() {
        return "Boss{" +
                "car=" + car +
                '}';
    }
}
```

我们采用Bean的方式注册一个组件时，如果有参数，也可以自动装配

```java
@Configuration
@ComponentScan({"com.hx.controller","com.hx.service","com.hx.Repository","com.hx.bean"})
//@Import(value = {BookController.class, BookService.class, BookDao.class})

public class AutoWiredConfig {


    @Primary //指明当前的Bean为默认首选的Bean
    @Bean("bookDao2")
    public BookDao bookDao(){
        BookDao bookDao = new BookDao();
        bookDao.setLabel("2");
        return bookDao;
    }

    @Bean
    public Color color(Car car){ //这里使用了参数的自动装配，@Autowired 是省略了的
        Color color = new Color();
        color.setCar(car);
        return color;
    }
}
```

### 5)实现XXXAware 接口，来获取Spring底层的对象



这种方式是在IOC容器创建对象时，采用回调方法的方式，注入ApplicationContext

这里的ApplicationContextAware 对应的后置处理器就是ApplicationContextAwareProcessor

其他类似的Aware接口也是同样的，XXXAwareProcessor 来处理的回调

```java
public class Dog implements ApplicationContextAware {

    private ApplicationContext applicationContext; //用一个变量保存起来

    public Dog(){
        System.out.println("Dog contructor...");
    }

    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
        this.applicationContext = applicationContext; 
    }
}
```

这种接口有很多Aware

```java
@Component
public class Red implements EmbeddedValueResolverAware, ApplicationContextAware {
    private ApplicationContext applicationContext;

    //获取IOC容器
    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
        this.applicationContext = applicationContext;
    }

    //得到Spring底层的字符串表达式解析器 ${} 可以获取到环境变量的值
    public void setEmbeddedValueResolver(StringValueResolver resolver) {
        String stringValue = resolver.resolveStringValue("我的系统是 ${os.name} SpEL表达式值=#{20*5}");
        System.out.println(stringValue);


    }
}

```



### 6)@Profile 根据环境动态激活和切换一系列组件

如：开发环境、测试环境、生产环境的动态切换，导致的数据源的动态切换。

maven中央仓库：http://mavenrepository.com 可以导入第三方的包



















































































